"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var TezosCurves = exports.TezosCurves = {
  ED25519: 0x00,
  SECP256K1: 0x01,
  SECP256R1: 0x02
}; /********************************************************************************
    *   Ledger Node JS API
    *   (c) 2016-2017 Ledger
    *
    *  Licensed under the Apache License, Version 2.0 (the "License");
    *  you may not use this file except in compliance with the License.
    *  You may obtain a copy of the License at
    *
    *      http://www.apache.org/licenses/LICENSE-2.0
    *
    *  Unless required by applicable law or agreed to in writing, software
    *  distributed under the License is distributed on an "AS IS" BASIS,
    *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    *  See the License for the specific language governing permissions and
    *  limitations under the License.
    ********************************************************************************/


/**
 * Tezos API
 *
 * @example
 * import Tezos from "@ledgerhq/hw-app-xtz";
 * const tez = new Tezos(transport)
 */
var Tezos = function () {
  function Tezos(transport) {
    _classCallCheck(this, Tezos);

    this.transport = transport;
    transport.decorateAppAPIMethods(this, ["getAddress", "signOperation", "signHash", "getVersion"], "XTZ");
  }

  /**
   * get Tezos address for a given BIP 32 path.
   * @param path a path in BIP 32 format, must begin with 44'/1729'
   * @option boolDisplay optionally enable or not the display
   * @option boolChaincode optionally enable or not the chaincode request
   * @option apdu to use a custom apdu. This should currently only be unset (which will choose
             an appropriate APDU based on the boolDisplay parameter), or else set to 0x0A
             for the special "display" APDU which uses the alternate copy "Your Key"
   * @return an object with a publicKey
   * @example
   * tez.getAddress("44'/1729'/0'/0'").then(o => o.address)
   */


  _createClass(Tezos, [{
    key: "getAddress",
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path, boolDisplay, curve, apdu // TODO specify
      ) {
        var cla, p1, p2, paths, buffer, payload, publicKeyLength, publicKey, res;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cla = 0x80;

                if (!apdu) {
                  if (boolDisplay) {
                    apdu = 0x03;
                  } else {
                    apdu = 0x02;
                  }
                }
                p1 = 0;
                p2 = curve || 0;
                paths = splitPath(path);
                buffer = new Buffer(1 + paths.length * 4);

                buffer[0] = paths.length;
                paths.forEach(function (element, index) {
                  buffer.writeUInt32BE(element, 1 + 4 * index);
                });

                _context.next = 10;
                return this.transport.send(cla, apdu, p1, p2, buffer);

              case 10:
                payload = _context.sent;
                publicKeyLength = payload[0];
                publicKey = payload.slice(1, 1 + publicKeyLength);
                res = {
                  publicKey: publicKey.toString("hex")
                };
                return _context.abrupt("return", res);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getAddress(_x, _x2, _x3, _x4) {
        return _ref.apply(this, arguments);
      }

      return getAddress;
    }()
  }, {
    key: "sign",
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(path, rawTxHex, curve, apdu) {
        var paths, offset, rawTx, toSend, buffer, maxChunkSize, chunkSize, _buffer, response, i, data, code, signature, parseError, signature_buffer, r_val, s_val, idx, frameType, r_length, s_length;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                paths = splitPath(path);
                offset = 0;
                rawTx = new Buffer(rawTxHex, "hex");
                toSend = [];

                // Initial key setting

                buffer = new Buffer(paths.length * 4 + 1);

                buffer[0] = paths.length;
                paths.forEach(function (element, index) {
                  buffer.writeUInt32BE(element, 1 + 4 * index);
                });
                toSend.push(buffer);


                while (offset !== rawTx.length) {
                  maxChunkSize = 230;
                  chunkSize = void 0;

                  if (offset + maxChunkSize >= rawTx.length) {
                    chunkSize = rawTx.length - offset;
                  } else {
                    chunkSize = maxChunkSize;
                  }
                  _buffer = new Buffer(chunkSize);

                  rawTx.copy(_buffer, 0, offset, offset + chunkSize);
                  toSend.push(_buffer);
                  offset += chunkSize;
                }

                response = void 0;
                i = 0;

              case 11:
                if (!(i < toSend.length)) {
                  _context2.next = 21;
                  break;
                }

                data = toSend[i];
                code = 0x01;

                if (i === 0) {
                  code = 0x00;
                } else if (i === toSend.length - 1) {
                  code = 0x81;
                }
                _context2.next = 17;
                return this.transport.send(0x80, apdu, code, curve, data);

              case 17:
                response = _context2.sent;

              case 18:
                i++;
                _context2.next = 11;
                break;

              case 21:
                signature = void 0;

                if (curve == 0) {
                  // tz1 signatures come correctly formatted from the ledger.
                  signature = response.slice(0, response.length - 2).toString("hex");
                } else {
                  // tz2 and tz3 signatures are in DER format from the ledger.
                  parseError = function parseError() {
                    throw new Error("Cannot parse ledger response.");
                  };

                  signature_buffer = new Buffer(64);

                  signature_buffer.fill(0);
                  r_val = signature_buffer.subarray(0, 32);
                  s_val = signature_buffer.subarray(32, 64);
                  idx = 0;
                  frameType = response.readUInt8(idx++);
                  // Accept either an ASN.1 sequence or ASN.1 set

                  if (frameType != 0x31 && frameType != 0x30) parseError();

                  // We are two bytes into the signature, and there are two bytes after the
                  // signature in response, so length +4 here.
                  if (response.readUInt8(idx++) + 4 != response.length) parseError();
                  if (response.readUInt8(idx++) != 0x02) parseError();
                  r_length = response.readUInt8(idx++);

                  if (r_length > 32) {
                    // Handle forced 0x00 33rd byte from DER format
                    idx += r_length - 32;
                    r_length = 32;
                  }
                  response.copy(r_val, 32 - r_length, idx, idx + r_length);
                  idx += r_length;
                  if (response.readUInt8(idx++) != 0x02) parseError();
                  s_length = response.readUInt8(idx++);

                  if (s_length > 32) {
                    // Handle forced 0x00 33rd byte from DER format
                    idx += s_length - 32;
                    s_length = 32;
                  }
                  response.copy(s_val, 32 - s_length, idx, idx + s_length);
                  idx += s_length;

                  // We should have just the two bytes at the end of the ledger response left.
                  if (idx != response.length - 2) parseError();

                  signature = signature_buffer.toString("hex");
                }
                return _context2.abrupt("return", { signature: signature });

              case 24:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function sign(_x5, _x6, _x7, _x8) {
        return _ref2.apply(this, arguments);
      }

      return sign;
    }()
  }, {
    key: "signOperation",
    value: function () {
      var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(path, rawTxHex, curve) {
        var result;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                curve = curve ? curve : 0x00;
                _context3.next = 3;
                return this.sign(path, rawTxHex, curve, 0x04);

              case 3:
                result = _context3.sent;
                return _context3.abrupt("return", result);

              case 5:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function signOperation(_x9, _x10, _x11) {
        return _ref3.apply(this, arguments);
      }

      return signOperation;
    }()
  }, {
    key: "signHash",
    value: function () {
      var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(path, rawTxHex, curve) {
        var result;
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                curve = curve ? curve : 0x00;
                _context4.next = 3;
                return this.sign(path, rawTxHex, curve, 0x05);

              case 3:
                result = _context4.sent;
                return _context4.abrupt("return", result);

              case 5:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function signHash(_x12, _x13, _x14) {
        return _ref4.apply(this, arguments);
      }

      return signHash;
    }()
  }, {
    key: "getVersion",
    value: function () {
      var _ref5 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var _ref6, _ref7, appFlag, major, minor, patch, bakingApp;

        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.next = 2;
                return this.transport.send(0x80, 0x00, 0x00, 0x00, new Buffer(0));

              case 2:
                _ref6 = _context5.sent;
                _ref7 = _slicedToArray(_ref6, 4);
                appFlag = _ref7[0];
                major = _ref7[1];
                minor = _ref7[2];
                patch = _ref7[3];
                bakingApp = appFlag === 1;
                return _context5.abrupt("return", { major: major, minor: minor, patch: patch, bakingApp: bakingApp });

              case 10:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function getVersion() {
        return _ref5.apply(this, arguments);
      }

      return getVersion;
    }()
  }]);

  return Tezos;
}();

// TODO use bip32-path library


exports.default = Tezos;
function splitPath(path) {
  var result = [];
  var components = path.split("/");
  components.forEach(function (element) {
    var number = parseInt(element, 10);
    if (isNaN(number)) {
      return; // FIXME shouldn't it throws instead?
    }
    if (element.length > 1 && element[element.length - 1] === "'") {
      number += 0x80000000;
    }
    result.push(number);
  });
  return result;
}
//# sourceMappingURL=Tezos.js.map
{"version":3,"sources":["../src/Transport.js"],"names":["Transport","exchangeTimeout","_events","EventEmitter","send","cla","ins","p1","p2","data","Buffer","alloc","statusList","StatusCodes","OK","length","TransportError","response","exchange","concat","from","sw","readUInt16BE","some","s","TransportStatusError","exchangeBusyPromise","exchangeAtomicImpl","f","resolveBusy","busyPromise","Promise","r","res","_appAPIlock","_apdu","Error","setScrambleKey","_key","close","resolve","on","eventName","cb","off","removeListener","emit","event","args","setDebugMode","console","warn","setExchangeTimeout","create","openTimeout","listenTimeout","reject","found","sub","listen","next","e","unsubscribe","listenTimeoutId","clearTimeout","open","descriptor","then","error","complete","ErrorMessage_NoDeviceFound","setTimeout","ErrorMessage_ListenTimeout","decorateAppAPIMethods","self","methods","scrambleKey","methodName","decorateAppAPIMethod","ctx","apply","isSupported","list"],"mappings":"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","sourcesContent":["//@flow\n\nimport EventEmitter from \"events\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport {\n  TransportError,\n  StatusCodes,\n  getAltStatusMessage,\n  TransportStatusError\n} from \"@ledgerhq/errors\";\n\nexport {\n  TransportError,\n  TransportStatusError,\n  StatusCodes,\n  getAltStatusMessage\n};\n\n/**\n */\nexport type Subscription = { unsubscribe: () => void };\n\n/**\n */\nexport type Device = Object;\n\n/**\n * type: add or remove event\n * descriptor: a parameter that can be passed to open(descriptor)\n * deviceModel: device info on the model (is it a nano s, nano x, ...)\n * device: transport specific device info\n */\nexport type DescriptorEvent<Descriptor> = {\n  type: \"add\" | \"remove\",\n  descriptor: Descriptor,\n  deviceModel?: ?DeviceModel,\n  device?: Device\n};\n/**\n */\nexport type Observer<Ev> = $ReadOnly<{\n  next: (event: Ev) => mixed,\n  error: (e: any) => mixed,\n  complete: () => mixed\n}>;\n\n/**\n * Transport defines the generic interface to share between node/u2f impl\n * A **Descriptor** is a parametric type that is up to be determined for the implementation.\n * it can be for instance an ID, an file path, a URL,...\n */\nexport default class Transport<Descriptor> {\n  exchangeTimeout: number = 30000;\n\n  /**\n   * Statically check if a transport is supported on the user's platform/browser.\n   */\n  static +isSupported: () => Promise<boolean>;\n\n  /**\n   * List once all available descriptors. For a better granularity, checkout `listen()`.\n   * @return a promise of descriptors\n   * @example\n   * TransportFoo.list().then(descriptors => ...)\n   */\n  static +list: () => Promise<Array<Descriptor>>;\n\n  /**\n   * Listen all device events for a given Transport. The method takes an Obverver of DescriptorEvent and returns a Subscription (according to Observable paradigm https://github.com/tc39/proposal-observable )\n   * a DescriptorEvent is a `{ descriptor, type }` object. type can be `\"add\"` or `\"remove\"` and descriptor is a value you can pass to `open(descriptor)`.\n   * each listen() call will first emit all potential device already connected and then will emit events can come over times,\n   * for instance if you plug a USB device after listen() or a bluetooth device become discoverable.\n   * @param observer is an object with a next, error and complete function (compatible with observer pattern)\n   * @return a Subscription object on which you can `.unsubscribe()` to stop listening descriptors.\n   * @example\nconst sub = TransportFoo.listen({\n  next: e => {\n    if (e.type===\"add\") {\n      sub.unsubscribe();\n      const transport = await TransportFoo.open(e.descriptor);\n      ...\n    }\n  },\n  error: error => {},\n  complete: () => {}\n})\n   */\n  static +listen: (\n    observer: Observer<DescriptorEvent<Descriptor>>\n  ) => Subscription;\n\n  /**\n   * attempt to create a Transport instance with potentially a descriptor.\n   * @param descriptor: the descriptor to open the transport with.\n   * @param timeout: an optional timeout\n   * @return a Promise of Transport instance\n   * @example\nTransportFoo.open(descriptor).then(transport => ...)\n   */\n  static +open: (\n    descriptor: Descriptor,\n    timeout?: number\n  ) => Promise<Transport<Descriptor>>;\n\n  /**\n   * low level api to communicate with the device\n   * This method is for implementations to implement but should not be directly called.\n   * Instead, the recommanded way is to use send() method\n   * @param apdu the data to send\n   * @return a Promise of response data\n   */\n  exchange(_apdu: Buffer): Promise<Buffer> {\n    throw new Error(\"exchange not implemented\");\n  }\n\n  /**\n   * set the \"scramble key\" for the next exchanges with the device.\n   * Each App can have a different scramble key and they internally will set it at instanciation.\n   * @param key the scramble key\n   */\n  setScrambleKey(_key: string) {}\n\n  /**\n   * close the exchange with the device.\n   * @return a Promise that ends when the transport is closed.\n   */\n  close(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  _events = new EventEmitter();\n\n  /**\n   * Listen to an event on an instance of transport.\n   * Transport implementation can have specific events. Here is the common events:\n   * * `\"disconnect\"` : triggered if Transport is disconnected\n   */\n  on(eventName: string, cb: Function) {\n    this._events.on(eventName, cb);\n  }\n\n  /**\n   * Stop listening to an event on an instance of transport.\n   */\n  off(eventName: string, cb: Function) {\n    this._events.removeListener(eventName, cb);\n  }\n\n  emit(event: string, ...args: *) {\n    this._events.emit(event, ...args);\n  }\n\n  /**\n   * Enable or not logs of the binary exchange\n   */\n  setDebugMode() {\n    console.warn(\n      \"setDebugMode is deprecated. use @ledgerhq/logs instead. No logs are emitted in this anymore.\"\n    );\n  }\n\n  /**\n   * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)\n   */\n  setExchangeTimeout(exchangeTimeout: number) {\n    this.exchangeTimeout = exchangeTimeout;\n  }\n\n  /**\n   * wrapper on top of exchange to simplify work of the implementation.\n   * @param cla\n   * @param ins\n   * @param p1\n   * @param p2\n   * @param data\n   * @param statusList is a list of accepted status code (shorts). [0x9000] by default\n   * @return a Promise of response buffer\n   */\n  send = async (\n    cla: number,\n    ins: number,\n    p1: number,\n    p2: number,\n    data: Buffer = Buffer.alloc(0),\n    statusList: Array<number> = [StatusCodes.OK]\n  ): Promise<Buffer> => {\n    if (data.length >= 256) {\n      throw new TransportError(\n        \"data.length exceed 256 bytes limit. Got: \" + data.length,\n        \"DataLengthTooBig\"\n      );\n    }\n    const response = await this.exchange(\n      Buffer.concat([\n        Buffer.from([cla, ins, p1, p2]),\n        Buffer.from([data.length]),\n        data\n      ])\n    );\n    const sw = response.readUInt16BE(response.length - 2);\n    if (!statusList.some(s => s === sw)) {\n      throw new TransportStatusError(sw);\n    }\n    return response;\n  };\n\n  /**\n   * create() allows to open the first descriptor available or\n   * throw if there is none or if timeout is reached.\n   * This is a light helper, alternative to using listen() and open() (that you may need for any more advanced usecase)\n   * @example\nTransportFoo.create().then(transport => ...)\n   */\n  static create(\n    openTimeout?: number = 3000,\n    listenTimeout?: number\n  ): Promise<Transport<Descriptor>> {\n    return new Promise((resolve, reject) => {\n      let found = false;\n      const sub = this.listen({\n        next: e => {\n          found = true;\n          if (sub) sub.unsubscribe();\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          this.open(e.descriptor, openTimeout).then(resolve, reject);\n        },\n        error: e => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          reject(e);\n        },\n        complete: () => {\n          if (listenTimeoutId) clearTimeout(listenTimeoutId);\n          if (!found) {\n            reject(\n              new TransportError(\n                this.ErrorMessage_NoDeviceFound,\n                \"NoDeviceFound\"\n              )\n            );\n          }\n        }\n      });\n      const listenTimeoutId = listenTimeout\n        ? setTimeout(() => {\n            sub.unsubscribe();\n            reject(\n              new TransportError(\n                this.ErrorMessage_ListenTimeout,\n                \"ListenTimeout\"\n              )\n            );\n          }, listenTimeout)\n        : null;\n    });\n  }\n\n  exchangeBusyPromise: ?Promise<void>;\n\n  // $FlowFixMe\n  exchangeAtomicImpl = async f => {\n    if (this.exchangeBusyPromise) {\n      throw new TransportError(\"Transport race condition\", \"RaceCondition\");\n    }\n    let resolveBusy;\n    const busyPromise = new Promise(r => {\n      resolveBusy = r;\n    });\n    this.exchangeBusyPromise = busyPromise;\n    try {\n      const res = await f();\n      return res;\n    } finally {\n      if (resolveBusy) resolveBusy();\n      this.exchangeBusyPromise = null;\n    }\n  };\n\n  decorateAppAPIMethods(\n    self: Object,\n    methods: Array<string>,\n    scrambleKey: string\n  ) {\n    for (let methodName of methods) {\n      self[methodName] = this.decorateAppAPIMethod(\n        methodName,\n        self[methodName],\n        self,\n        scrambleKey\n      );\n    }\n  }\n\n  _appAPIlock = null;\n  decorateAppAPIMethod<R, A: any[]>(\n    methodName: string,\n    f: (...args: A) => Promise<R>,\n    ctx: *,\n    scrambleKey: string\n  ): (...args: A) => Promise<R> {\n    return async (...args) => {\n      const { _appAPIlock } = this;\n      if (_appAPIlock) {\n        return Promise.reject(\n          new TransportError(\n            \"Ledger Device is busy (lock \" + _appAPIlock + \")\",\n            \"TransportLocked\"\n          )\n        );\n      }\n      try {\n        this._appAPIlock = methodName;\n        this.setScrambleKey(scrambleKey);\n        return await f.apply(ctx, args);\n      } finally {\n        this._appAPIlock = null;\n      }\n    };\n  }\n\n  static ErrorMessage_ListenTimeout = \"No Ledger device found (timeout)\";\n  static ErrorMessage_NoDeviceFound = \"No Ledger device found\";\n}\n"],"file":"Transport.js"}